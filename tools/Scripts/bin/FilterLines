#!/usr/bin/env python

# FilterLines

# examples:
#
# cat foo.txt | Filterlines "bla"
#    shows all lines from foo.txt that contain the regexp "bla"
#
# cat foo.txt | Filterlines "bla" "goob"
#    shows all lines from foo.txt that contain the regexp "bla" OR the regexp "goob"
#
# cat foo.txt | Filterlines "bla" "goob" -n "mac"
#    shows all lines from foo.txt that contain the regexp "bla" OR the regexp "goob" but NOT the regexp "mac"
#
# cat foo.txt | Filterlines "bla" "goob" -n "mac" "ops"
#    shows all lines from foo.txt that contain the regexp "bla" OR the regexp "goob" but NEITHER "mac" OR "ops"
#
# cat foo.txt | Filterlines "bla" -n "goob" "mac" "ops"
#    shows all lines from foo.txt that contain the regexp "bla" and don't contain "goob", "mac" or "ops"
#
# cat foo.txt | Filterlines -n "bla" "goob" "mac" "ops"
#    shows all lines from foo.txt that don't contain "bla", "goob", "mac" or "ops"
#
# I think you got it by now.

import sys,re

skip = 0
only = 1

# XXX I really need a Python option parser...
mode = only
if len(sys.argv) < 2:
    print "Pass regexps to filter as a parameter."
    sys.exit(1)

patterns = sys.argv[1:]

def split_list(list, delim):
    for i in range(len(list)):
        if list[i] == delim:
	    return list[:i], list[i+1:]
    return list, []

positives, negatives = split_list(patterns, "-n")

posrxs = map(re.compile, positives)
negrxs = map(re.compile, negatives)

ls = sys.stdin.readlines()
for l in ls:
    def match_one(rxs, l, empty=0):
	if rxs == []:
	    return empty
	for rx in rxs:
	    if rx.search(l) != None:
		return 1
	return 0
    if (match_one(posrxs, l, 1) and not match_one(negrxs, l)):
	print l,
